// http://docs.aws.amazon.com/AWSMechTurk/latest/AWSMechanicalTurkRequester/MakingRequests_RequestAuthenticationArticle.html

// 1 The sender constructs a request to AWS.
// 2 The sender calculates a Keyed-Hashing for Message Authentication code (HMAC), the request signature using the his or her Secret Access Key and the values of the Service, Operation, and Timestamp parameters as input.
// 3 The sender of the request sends the request data, the signature, and Access Key ID (the key-identifier of the Secret Access Key used) to AWS.
// 4 AWS uses the Access Key ID to look up the Secret Access Key.
// 5 AWS generates a signature from the request data and the Secret Access Key using the same algorithm used to calculate the signature in the request.
// 6 If the signature generated by AWS matches the one sent in the request, the request is considered to be authentic. If the comparison fails, the request is discarded, and AWS returns an error response.

package main

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/xml"
	"net/http"
	"time"
)

const endpoint = `https://route53.amazonaws.com`
const api = `2012-12-12`
const Route53URL = endpoint + `/` + api + `/`
const requestExpired = `RequestExpired`

type AccessIdentifiers struct {
	AccessKey string
	SecretKey string
}

type ZoneRequest struct {
	XMLName          xml.Name
	Name             string
	CallerReference  string
	HostedZoneConfig HostedZoneConfig
}

type HostedZoneConfig struct {
	Comment string
}

type HostedZone struct {
	AccessIdentifiers AccessIdentifiers
	HostedZoneRequest ZoneRequest
	Endpoint          string
}

func (c *HostedZone) CreateHostedZone() (req *http.Response, err error) {
	if c.Endpoint == "" {
		c.Endpoint = Route53URL + "hostedzone"
	}
	date := time.Now()
	signature := signature(c.AccessIdentifiers.SecretKey, date)
	postData, err := createHostedZoneXML(c.HostedZoneRequest)
	if err != nil {
		return nil, err
	}
	headers := http.Header{}
	headers.Add("Date", date.UTC().Format(time.ANSIC))
	headers.Add("Content-Type", "text/xml; charset=UTF-8")
	headers.Add("X-Amzn-Authorization", "AWS3-HTTPS AWSAccessKeyId="+c.AccessIdentifiers.AccessKey+",Algorithm=HmacSHA256,Signature="+signature)
	req, err = remotePost(c.Endpoint, postData, headers)
	return
}

func signature(AWSSecretKey string, t time.Time) (sha string) {
	time := t.UTC().Format(time.ANSIC)
	hash := hmac.New(sha256.New, []byte(AWSSecretKey))
	hash.Write([]byte(time))
	sha = base64.StdEncoding.EncodeToString(hash.Sum(nil))
	return
}

func createHostedZoneXML(hostedZoneRequest ZoneRequest) (response string, err error) {
	hostedZoneRequest.XMLName = xml.Name{
		Space: endpoint + `/doc/` + api + `/`,
		Local: "CreateHostedZoneRequest",
	}
	byteXML, err := xml.MarshalIndent(hostedZoneRequest, "", `   `)
	if err != nil {
		return "", err
	}
	response = xml.Header + string(byteXML)
	return
}

func remoteTime(url string) (time string, err error) {
	headers, err := remoteHeaders(url)
	if err != nil {
		return time, err
	}
	time = headers.Get("Date")
	return
}

func remoteHeaders(url string) (http.Header, error) {
	resp, err := http.Head(url)
	if err != nil {
		return nil, err
	}
	return resp.Header, nil
}

func remotePost(url string, postData string, headers http.Header) (*http.Response, error) {
	req, err := http.NewRequest("POST", url, bytes.NewReader([]byte(postData)))
	
	if err != nil {
		return nil, err
	}

	// there must be a better way of doing this
	for key, value := range headers {
		req.Header.Add(key, value[0])
	}

	client := &http.Client{}
	res, err := client.Do(req)

	if err != nil {
		return nil, err
	}

	return res, err
}

func main() {

}
